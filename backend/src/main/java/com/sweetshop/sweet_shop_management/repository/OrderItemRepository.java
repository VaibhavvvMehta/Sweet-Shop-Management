package com.sweetshop.sweet_shop_management.repository;

import com.sweetshop.sweet_shop_management.model.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository interface for OrderItem entity operations.
 * Provides custom queries for order item management and analysis.
 * 
 * @author Sweet Shop Management System
 * @version 1.0
 */
@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

    /**
     * Find order items by order ID
     * 
     * @param orderId the order ID
     * @return list of order items for the specified order
     */
    List<OrderItem> findByOrderId(Long orderId);

    /**
     * Find order items by sweet ID
     * 
     * @param sweetId the sweet ID
     * @return list of order items containing the specified sweet
     */
    List<OrderItem> findBySweetId(Long sweetId);

    /**
     * Find order items by order ID and sweet ID
     * 
     * @param orderId the order ID
     * @param sweetId the sweet ID
     * @return order item if exists
     */
    Optional<OrderItem> findByOrderIdAndSweetId(Long orderId, Long sweetId);

    /**
     * Find all order items for orders with specific status
     * 
     * @param status the order status
     * @return list of order items from orders with the specified status
     */
    @Query("SELECT oi FROM OrderItem oi JOIN oi.order o WHERE o.status = :status")
    List<OrderItem> findByOrderStatus(@Param("status") com.sweetshop.sweet_shop_management.model.Order.OrderStatus status);

    /**
     * Get total quantity sold for a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return total quantity sold
     */
    @Query("SELECT SUM(oi.quantity) FROM OrderItem oi JOIN oi.order o WHERE oi.sweet.id = :sweetId AND o.status IN ('DELIVERED', 'COMPLETED')")
    Optional<Long> getTotalQuantitySoldForSweet(@Param("sweetId") Long sweetId);

    /**
     * Get total revenue generated by a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return total revenue from the sweet
     */
    @Query("SELECT SUM(oi.subtotal) FROM OrderItem oi JOIN oi.order o WHERE oi.sweet.id = :sweetId AND o.status IN ('DELIVERED', 'COMPLETED')")
    Optional<Double> getTotalRevenueForSweet(@Param("sweetId") Long sweetId);

    /**
     * Find top-selling sweets (by quantity) within a date range
     * 
     * @param startDate the start date
     * @param endDate the end date
     * @param limit the maximum number of results to return
     * @return list of objects containing sweet ID, name, and total quantity sold
     */
    @Query(value = "SELECT oi.sweet_id, s.name, SUM(oi.quantity) as total_quantity " +
           "FROM order_items oi " +
           "JOIN orders o ON oi.order_id = o.id " +
           "JOIN sweets s ON oi.sweet_id = s.id " +
           "WHERE o.status IN ('DELIVERED', 'COMPLETED') " +
           "AND o.completed_at BETWEEN :startDate AND :endDate " +
           "GROUP BY oi.sweet_id, s.name " +
           "ORDER BY total_quantity DESC " +
           "LIMIT :limit", nativeQuery = true)
    List<Object[]> findTopSellingSweets(@Param("startDate") LocalDateTime startDate, 
                                       @Param("endDate") LocalDateTime endDate, 
                                       @Param("limit") int limit);

    /**
     * Find most profitable sweets (by revenue) within a date range
     * 
     * @param startDate the start date
     * @param endDate the end date
     * @param limit the maximum number of results to return
     * @return list of objects containing sweet ID, name, and total revenue
     */
    @Query(value = "SELECT oi.sweet_id, s.name, SUM(oi.subtotal) as total_revenue " +
           "FROM order_items oi " +
           "JOIN orders o ON oi.order_id = o.id " +
           "JOIN sweets s ON oi.sweet_id = s.id " +
           "WHERE o.status IN ('DELIVERED', 'COMPLETED') " +
           "AND o.completed_at BETWEEN :startDate AND :endDate " +
           "GROUP BY oi.sweet_id, s.name " +
           "ORDER BY total_revenue DESC " +
           "LIMIT :limit", nativeQuery = true)
    List<Object[]> findMostProfitableSweets(@Param("startDate") LocalDateTime startDate, 
                                           @Param("endDate") LocalDateTime endDate, 
                                           @Param("limit") int limit);

    /**
     * Get sales data by sweet category
     * 
     * @param startDate the start date
     * @param endDate the end date
     * @return list of objects containing category, total quantity, and total revenue
     */
    @Query("SELECT s.category, SUM(oi.quantity), SUM(oi.subtotal) " +
           "FROM OrderItem oi JOIN oi.order o JOIN oi.sweet s " +
           "WHERE o.status IN ('DELIVERED', 'COMPLETED') " +
           "AND o.completedAt BETWEEN :startDate AND :endDate " +
           "GROUP BY s.category " +
           "ORDER BY SUM(oi.subtotal) DESC")
    List<Object[]> getSalesByCategory(@Param("startDate") LocalDateTime startDate, 
                                     @Param("endDate") LocalDateTime endDate);

    /**
     * Count order items in active orders for a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return count of order items in active orders
     */
    @Query("SELECT COUNT(oi) FROM OrderItem oi JOIN oi.order o WHERE oi.sweet.id = :sweetId AND o.status IN ('PENDING', 'CONFIRMED', 'PREPARING', 'READY', 'OUT_FOR_DELIVERY')")
    long countActiveOrderItemsForSweet(@Param("sweetId") Long sweetId);

    /**
     * Get total quantity in active orders for a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return total quantity in active orders
     */
    @Query("SELECT SUM(oi.quantity) FROM OrderItem oi JOIN oi.order o WHERE oi.sweet.id = :sweetId AND o.status IN ('PENDING', 'CONFIRMED', 'PREPARING', 'READY', 'OUT_FOR_DELIVERY')")
    Optional<Long> getTotalQuantityInActiveOrdersForSweet(@Param("sweetId") Long sweetId);

    /**
     * Find order items with quantity greater than specified value
     * 
     * @param minQuantity the minimum quantity
     * @return list of order items with quantity greater than the specified value
     */
    List<OrderItem> findByQuantityGreaterThan(Integer minQuantity);

    /**
     * Find order items created within a date range
     * 
     * @param startDate the start date
     * @param endDate the end date
     * @return list of order items created within the date range
     */
    List<OrderItem> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Check if any order items exist for a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return true if order items exist for the sweet
     */
    boolean existsBySweetId(Long sweetId);

    /**
     * Delete all order items for a specific order
     * 
     * @param orderId the order ID
     */
    void deleteByOrderId(Long orderId);

    /**
     * Get average order item quantity for a specific sweet
     * 
     * @param sweetId the sweet ID
     * @return average quantity per order item
     */
    @Query("SELECT AVG(oi.quantity) FROM OrderItem oi WHERE oi.sweet.id = :sweetId")
    Optional<Double> getAverageQuantityForSweet(@Param("sweetId") Long sweetId);

    /**
     * Find order items with notes
     * 
     * @return list of order items that have notes
     */
    @Query("SELECT oi FROM OrderItem oi WHERE oi.notes IS NOT NULL AND oi.notes != ''")
    List<OrderItem> findOrderItemsWithNotes();

    /**
     * Get daily sales summary for a date range
     * 
     * @param startDate the start date
     * @param endDate the end date
     * @return list of objects containing date, total quantity, and total revenue per day
     */
    @Query(value = "SELECT DATE(o.completed_at) as sale_date, SUM(oi.quantity) as total_quantity, SUM(oi.subtotal) as total_revenue " +
           "FROM order_items oi " +
           "JOIN orders o ON oi.order_id = o.id " +
           "WHERE o.status IN ('DELIVERED', 'COMPLETED') " +
           "AND o.completed_at BETWEEN :startDate AND :endDate " +
           "GROUP BY DATE(o.completed_at) " +
           "ORDER BY sale_date DESC", nativeQuery = true)
    List<Object[]> getDailySalesSummary(@Param("startDate") LocalDateTime startDate, 
                                       @Param("endDate") LocalDateTime endDate);
}